use async_graphql::{Context, Error, Object, Result};
use bson::Uuid;
use futures::future::try_join_all;
use s3::Bucket;
use url::Url;

/// Defines pre-signed URL expiration time of 1d.
pub static PATH_EXPIRATION_TIME: u32 = 86400;
/// Path under which MinIO is available through a reserve proxy, for example Nginx.
/// This should be defined in the reverse proxies configuration.
pub static PROXY_PATH: &'static str = "/api/media";

/// Describes GraphQL invoice queries.
pub struct Query;

#[Object]
impl Query {
    /// Returns a pre-signed path for a media of a specific UUID.
    ///
    /// Sets the path generated by MinIO behind PROXY_PATH.
    /// Creates pre-signed paths with PATH_EXPIRATION_TIME.
    #[graphql(inaccessible)]
    async fn get_media_path<'a>(
        &self,
        ctx: &Context<'a>,
        #[graphql(desc = "UUID of media file which a pre-signed path should be created for.")]
        id: Uuid,
    ) -> Result<String> {
        let media_data_bucket = ctx.data::<Bucket>()?;
        let mut list_bucket_results = media_data_bucket.list(id.to_string(), None).await?;
        let message = format!("Media file of UUID: `{}` not found.", id);
        let mut list_bucket_result = list_bucket_results
            .pop()
            .ok_or(Error::new(message.clone()))?;
        let media_file_name = list_bucket_result
            .contents
            .pop()
            .ok_or(Error::new(message))?
            .key;
        let media_file_url_string =
            media_data_bucket.presign_get(media_file_name, PATH_EXPIRATION_TIME, None)?;
        let media_file_url = Url::parse(&media_file_url_string)?;
        let media_file_path = format!(
            "{}{}?{}",
            PROXY_PATH,
            media_file_url.path(),
            media_file_url.query().unwrap_or("")
        );
        Ok(media_file_path)
    }

    /// Returns pre-signed paths for a medias of UUIDs.
    ///
    /// Uses `self.get_media_path` to compute multiple media paths.
    async fn get_media_paths<'a>(
        &self,
        ctx: &Context<'a>,
        #[graphql(desc = "UUIDs of media file which a pre-signed path should be created for.")] ids: Vec<Uuid>,
    ) -> Result<Vec<String>> {
        let media_path_futures = ids.iter().map(|id| self.get_media_path(&ctx, *id));
        try_join_all(media_path_futures).await
    }
}
